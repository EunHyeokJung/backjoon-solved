DP (Dynamic Programming)
===
정은혁 알고리즘 - DP 중, README.md

# 1. WHAT IS 'DP'

---

### DP(Dynamic Programming)
#### DP는 '동적계획법'으로, Inductive reasoning을 기본으로 한다.

> Inductive reasoning
> 귀납 추론, 귀납법
> 
> 전체를 세부적인 부분으로 나누어 결론을 이끌어내는 추론법

### 주어진 문제보다 조금 더 작은 문제들의 답을 안다면, 더 큰 문제의 답을 구할 수 있다


# 2. DP의 구조

---

- 문제 표현과 매개변수

> - P(k)
> - P(n, m): n개에서 서로 다른 m개 선택하기

- 기저조건 (base condition)

> - 확정된 정답
> - n=1, 2일 떄의 정답

- 재귀식

> - N <= k-1 일 때의 모든 정답을 알고 있다고 가정
> - 그 다음 단계의 합을 구한다.
>   - ex) P(k) = max{ P(k-1), P(k-2) }

- Computing Resource

> - 부분 문제들의 답을 저장해 두어, 다시 계산하지 않도록 함.

# 3. DP의 해결 방법

---

### 1. 부분 문제들을 하나씩 순서대로 해결.

- 가장 작은 부분 문제를 먼저 해결한다.
- 큰 부분 문제를 해결하려고 할 때, 작은 부분 문제들의 답을 이용한다.
- 모든 부분 문제들을 다 해결할 때까지 지속한다.

### 2. 부분 문제들을 저장해두고, 이를 이용해 효율적으로 계산한다.

- 배열 등을 이용해 부분 문제들의 답을 저장
  - ex) P(k) = max{ P(k-1), P(k-2) }
  - 일차원 배열 T에 P(k-1), P(k-2)를 저장
  - P(k)를 해결할 때 위 두개를 이용하면 단시간에 계산 가능
    - P(k)를 T[k]에 저장해 다시 이용

### 3. 예시: n개의 가로 막대가 있는 사다리를 한번에 한 칸 또는 두 칸씩 올라갈 수 있다. 올라가는 방법의 수를 구해라.

#### 부분 문제 L(k) : 가로 막대가 k개 있을 때의 경우의 수

- L(1)=1, { 1 }
- L(2)=2, { 1+1, 2 }
- L(3)=3, { 1+1+1, 2+1, 1+2 }

#### 부분 문제들 사이의 관계 : L(k) = L(k-1) + L(k-2)

- k번째 칸에 도달하려면 1칸 아래 혹은 2칸 아래의 칸에서 한번에 이동

#### 해결 방법 : 작은 부분 문제부터 순서대로 해결

- 가장 작은 문제 L(1)부터 해결
- L(k-2)와 L(k-1)을 해결한 후 L(k)를 해결
- L(n)을 맨 마지막에 해결하면, L(n)의 값이 전체 문제의 답을 나타낸다.

# 4. 최적 부분문제 구조 (Optimal substructure)

---

### 1. 최적화의 원칙 (Principle of Optimality)

> 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.

 - 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 부분 문제들의 해 역시 최적이어야 한다는 것이다.
 - A -> B -> C가 최적일 때, A -> B와 B -> c 는 최적이어야 한다.

### 2. 최적화의 원칙이 적용되지 않는 예: 최장 경로 문제

> 최장 경로 : 그래프에서 두 정점을 가장 긴 길이로 연결하는 단순 경로
> 
> 단순 경로* : 그래프의 정점을 1번씩만 지나는 경로

![img.png](img/LongestPathImg.png)

- A에서 D로의 최장 경로는 [A, C, B, D]
- 그러나 A -> C에서는 [A, B, C]가 최장 경로

따라서 최장 경로 문제는 DP로 효율적으로 해결하기 어렵다.
